<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Resuscitation Handbook</title>
    <style>
        :root {
            /* Geometry */
            --wheel-diameter: 300px;
            --wheel-radius: 150px;
            --card-width: 180px;
            --card-height: 210px;
            --preview-width: 130px;
            --preview-height: 95px;
            --history-width: 120px;
            --history-height: 85px;
            --knob-size: 30px;
            
            /* Layout */
            --header-h: 50px;
            --footer-h: 100px;
            
            /* Colors */
            --primary: #1a1a1a;
            --bg: #f5f5f5;
            --card-bg: #d0d0d0;
            --accent-red: #d32f2f;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #222;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #app {
            width: 390px;
            height: 844px;
            background: var(--bg);
            position: relative;
            display: flex;
            flex-direction: column;
            border: 2px solid var(--primary);
            overflow: hidden;
        }

        /* === HEADER === */
        header {
            height: var(--header-h);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid var(--primary);
            background: white;
            flex-shrink: 0;
        }
        .app-title { font-weight: 700; font-size: 14px; }
        .header-icons { display: flex; gap: 10px; align-items: center; }
        .header-icon { width: 22px; height: 22px; cursor: pointer; }

        /* === STAGE (Main Area) === */
        #stage {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* === ZONE: TOP (Preview Stack) === */
        #zone-top {
            height: 170px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 8px;
        }

        /* === ZONE: MIDDLE (Wheel + Active Card) === */
        #zone-middle {
            height: calc(var(--wheel-diameter) + 20px);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The Wheel Circle */
        #wheel {
            width: var(--wheel-diameter);
            height: var(--wheel-diameter);
            border: 1px solid var(--primary);
            border-radius: 50%;
            position: absolute;
        }

        /* Active Card - INSIDE the wheel */
        #active-card {
            width: var(--card-width);
            height: var(--card-height);
            background: var(--card-bg);
            border: 2px solid var(--primary);
            border-radius: 8px;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 10;
            overflow: hidden;
        }

        #active-card.cover-mode {
            background: transparent;
            border: none;
        }

        #active-card.loop-mode {
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 8px 35px rgba(211, 47, 47, 0.4); border-color: var(--accent-red); }
        }

        /* The Knob */
        #knob {
            width: var(--knob-size);
            height: var(--knob-size);
            background: var(--primary);
            border-radius: 50%;
            position: absolute;
            z-index: 100;
            cursor: grab;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            transition: left 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        #knob:active { cursor: grabbing; }
        #knob.dragging { transition: none; }

        /* === ZONE: BOTTOM (History Stack) === */
        #zone-bottom {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 12px;
        }

        /* === FOOTER (Checklist + Timer) === */
        footer {
            height: var(--footer-h);
            padding: 8px 16px;
            border-top: 2px solid var(--primary);
            background: white;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }
        .footer-label { font-size: 11px; font-weight: 700; margin-bottom: 6px; color: #666; }
        .footer-row { display: flex; align-items: center; gap: 8px; flex: 1; }
        #checklist-area { 
            flex: 1; 
            border: 1px solid var(--primary); 
            padding: 6px 10px;
            overflow-y: auto;
            max-height: 60px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-content: flex-start;
        }
        .overflow-btn { font-size: 20px; font-weight: bold; cursor: pointer; padding: 0 5px; }
        #timer { 
            font-family: 'SF Mono', Monaco, monospace; 
            font-size: 13px; 
            padding: 8px 12px; 
            border: 1px solid var(--primary);
            background: white;
        }

        /* === CARD STYLES === */
        .card {
            background: var(--card-bg);
            border: 2px solid var(--primary);
            border-radius: 8px;
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .preview-card {
            width: var(--preview-width);
            height: var(--preview-height);
        }

        .history-card {
            width: var(--history-width);
            height: var(--history-height);
            opacity: 0.5;
            filter: grayscale(80%);
        }

        /* Card Content */
        .card-header { 
            font-size: 10px; 
            text-transform: uppercase; 
            color: #666; 
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .card-title { 
            font-size: 15px; 
            font-weight: 700; 
            margin-bottom: 6px;
            padding: 0 10px;
        }
        .card-body { 
            font-size: 12px; 
            color: #444;
            padding: 0 10px;
            line-height: 1.3;
        }

        /* Card Icons */
        .card-icon { position: absolute; width: 16px; height: 16px; opacity: 0.6; }
        .icon-tl { top: 6px; left: 6px; }
        .icon-tr { top: 6px; right: 6px; cursor: pointer; }
        .icon-bl { bottom: 6px; left: 6px; cursor: pointer; }
        .icon-br { bottom: 6px; right: 6px; }

        /* Decision Icon on Preview */
        .decision-indicator {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 14px;
            height: 14px;
        }

        /* Cover Text */
        .cover-content {
            text-align: center;
            padding: 20px;
        }
        .cover-title { font-size: 18px; font-weight: 700; margin-bottom: 8px; }
        .cover-subtitle { font-size: 12px; color: #666; }

        /* === DECISION MODE (Side-by-side options with preview stacks) === */
        #zone-top.decision-mode {
            flex-direction: row;
            justify-content: center;
            align-items: flex-end;
            gap: 12px;
            padding-bottom: 8px;
        }

        .decision-option-container {
            position: relative;
            width: calc(var(--preview-width) + 20px);
            height: calc(var(--preview-height) + 30px);
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        .decision-option-container.selected {
            /* Selected container is slightly larger to show stacks */
        }

        .preview-stack-card {
            position: absolute;
            width: var(--preview-width);
            height: var(--preview-height);
            background: #e0e0e0;
            border: 1px solid #999;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-stack-card .card-header.small {
            font-size: 8px;
        }

        .decision-option-card {
            width: var(--preview-width);
            height: var(--preview-height);
            background: var(--card-bg);
            border: 2px solid var(--primary);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: grab;
            position: relative;
        }

        .decision-option-card:active { cursor: grabbing; }

        .decision-option-card.selected {
            border-color: var(--accent-red);
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3);
            transform: scale(1.02);
        }

        .decision-option-card:not(.selected) {
            opacity: 0.6;
            transform: scale(0.92);
        }

        .decision-option-card .card-header {
            font-size: 9px;
            margin-bottom: 2px;
        }

        .decision-option-card .card-body.small {
            font-size: 9px;
            line-height: 1.2;
            max-height: 40px;
            overflow: hidden;
        }

        .option-badge {
            position: absolute;
            bottom: 6px;
            font-size: 14px;
            font-weight: 700;
            color: var(--primary);
            background: #f0f0f0;
            padding: 2px 10px;
            border-radius: 10px;
        }

        .decision-option-card.selected .option-badge {
            background: var(--accent-red);
            color: white;
        }

        /* === CHECKLIST ITEMS === */
        .check-item {
            display: flex;
            align-items: center;
            font-size: 12px;
            white-space: nowrap;
        }
        .check-item input {
            margin-right: 4px;
            width: 14px;
            height: 14px;
            accent-color: var(--primary);
        }
        .check-item.toggle-item input {
            accent-color: var(--accent-red);
        }
        .check-item.hidden { display: none; }

        /* === CAROUSEL DOTS === */
        .carousel-dots {
            display: flex;
            gap: 4px;
            position: absolute;
            bottom: 8px;
        }
        .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 1px solid var(--primary);
            background: transparent;
        }
        .dot.active { background: var(--primary); }

        /* === TOOLBOX MODAL === */
        #modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        #modal-overlay.visible { display: flex; }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        .modal-title { font-weight: 700; margin-bottom: 15px; }
        .modal-close {
            margin-top: 15px;
            padding: 8px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="app">
    <!-- Header -->
    <header>
        <div class="app-title">Resuscitation Handbook</div>
        <div class="header-icons">
            <svg class="header-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/>
            </svg>
            <svg class="header-icon" viewBox="0 0 24 24" fill="currentColor">
                <circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/>
            </svg>
        </div>
    </header>

    <!-- Stage -->
    <div id="stage">
        <div id="zone-top"></div>
        <div id="zone-middle">
            <div id="wheel"></div>
            <div id="active-card"></div>
            <div id="knob" tabindex="0" role="slider" aria-label="Navigation Control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-valuetext="Start"></div>
        </div>
        <div id="zone-bottom"></div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="footer-label">Check List</div>
        <div class="footer-row">
            <div id="checklist-area"></div>
            <div class="overflow-btn">⋮</div>
            <div id="timer">00:00:00</div>
        </div>
    </footer>

    <!-- Modal -->
    <div id="modal-overlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-title">Age Calculator</div>
            <p style="font-size:13px;color:#666;margin-bottom:10px;">Enter date of birth to determine category</p>
            <input type="date" style="padding:8px;width:100%;margin-bottom:10px;border:1px solid #ccc;border-radius:4px;">
            <p style="font-size:14px;"><strong>Result:</strong> Child (>1yr)</p>
            <button class="modal-close" onclick="closeModal()">Close</button>
        </div>
    </div>
</div>

<!-- SVG Symbols -->
<svg style="display:none">
    <symbol id="icon-fullscreen" viewBox="0 0 24 24">
        <path d="M4 4h4v2H6v2H4V4zm16 0h-4v2h2v2h2V4zM4 20h4v-2H6v-2H4v4zm16 0h-4v-2h2v-2h2v4z" fill="none" stroke="currentColor" stroke-width="1.5"/>
    </symbol>
    <symbol id="icon-toolbox" viewBox="0 0 24 24">
        <rect x="4" y="8" width="16" height="12" rx="1" fill="none" stroke="currentColor" stroke-width="1.5"/>
        <path d="M8 8V6a2 2 0 012-2h4a2 2 0 012 2v2" fill="none" stroke="currentColor" stroke-width="1.5"/>
        <path d="M12 12v4M10 14h4" stroke="currentColor" stroke-width="1.5"/>
    </symbol>
    <symbol id="icon-decision" viewBox="0 0 24 24">
        <path d="M12 4v6M12 10l-5 5M12 10l5 5" fill="none" stroke="currentColor" stroke-width="1.5"/>
        <rect x="5" y="15" width="4" height="4" fill="none" stroke="currentColor" stroke-width="1"/>
        <rect x="15" y="15" width="4" height="4" fill="none" stroke="currentColor" stroke-width="1"/>
    </symbol>
</svg>

<script>
// ========================================
// THE JSON DATA (From your file)
// ========================================
const DEFAULT_ALGORITHM = {
  "algorithm_meta": {
    "id": "algo_paed_bls_001",
    "title": "Paediatric Out-of-Hospital BLS",
    "source": "Resuscitation Council UK (2021)",
    "global_timer": { "enabled": true, "label": "Total Time", "type": "count_up" }
  },
  "deck": [
    {
      "id": "CARD_00_START",
      "type": "cover",
      "content": {
        "title": "Paediatric Basic Life Support",
        "subtitle": "Out-of-Hospital Algorithm",
        "footer_note": "Those trained only in adult BLS should use adult sequence with paediatric modifications."
      },
      "wheel_config": { "position_degrees": 330, "phase": "start_point" },
      "transitions": { "type": "linear", "next_id": "CARD_01_UNRESPONSIVE" }
    },
    {
      "id": "CARD_01_UNRESPONSIVE",
      "type": "standard",
      "content": { "title": "Assessment", "body": "Is the child unresponsive?", "slides": [] },
      "wheel_config": { "position_degrees": 0, "phase": "assessment" },
      "checklist": [
        { "id": "chk_safe", "label": "Area is safe to approach", "type": "checkbox" },
        { "id": "chk_unresp", "label": "Confirm Unresponsiveness", "type": "checkbox" }
      ],
      "transitions": { "type": "linear", "next_id": "CARD_02_SHOUT" }
    },
    {
      "id": "CARD_02_SHOUT",
      "type": "standard",
      "content": { "title": "Call for Help", "body": "Shout loudly for help.", "slides": [] },
      "wheel_config": { "position_degrees": 15, "phase": "action" },
      "checklist": [
        { "id": "toggle_2nd_rescuer", "label": "Is a 2nd rescuer present?", "type": "boolean_toggle" },
        { "id": "chk_call_999", "label": "Call EMS (999)", "type": "checkbox", "visible_if": "toggle_2nd_rescuer == true" },
        { "id": "chk_get_aed", "label": "Collect and apply AED", "type": "checkbox", "visible_if": "toggle_2nd_rescuer == true" }
      ],
      "transitions": { "type": "linear", "next_id": "CARD_03_AIRWAY" }
    },
    {
      "id": "CARD_03_AIRWAY",
      "type": "standard",
      "content": { "title": "Airway", "body": "Open Airway", "slides": [{ "label": "Technique", "text": "Head tilt, chin lift" }] },
      "wheel_config": { "position_degrees": 30, "phase": "action" },
      "transitions": { "type": "linear", "next_id": "CARD_04_BREATHING_DECISION" }
    },
    {
      "id": "CARD_04_BREATHING_DECISION",
      "type": "decision",
      "content": { "title": "Breathing Check", "body": "Is the child breathing normally?" },
      "wheel_config": { "position_degrees": 45, "phase": "decision" },
      "transitions": {
        "type": "split",
        "options": [
          { "label": "YES", "preview_card_title": "Observe & Assess", "target_id": "CARD_END_OBSERVE" },
          { "label": "NO", "sub_label": "or any doubt", "preview_card_title": "5 Rescue Breaths", "target_id": "CARD_05_BREATHS" }
        ]
      }
    },
    {
      "id": "CARD_END_OBSERVE",
      "type": "terminal",
      "content": { "title": "Observation", "body": "Observe and re-assess as necessary." },
      "wheel_config": { "position_degrees": 60, "phase": "complete" },
      "status": "complete"
    },
    {
      "id": "CARD_05_BREATHS",
      "type": "carousel_action",
      "content": {
        "title": "5 Rescue Breaths",
        "slides": [
          { "id": "slide_infant", "header": "Infant Technique", "text": "Mouth to nose/mouth" },
          { "id": "slide_child", "header": "Child Technique", "text": "Mouth to mouth" }
        ]
      },
      "wheel_config": { "position_degrees": 90, "phase": "intervention" },
      "toolbox": [{ "id": "calc_age", "icon": "calculator", "label": "Age Calculator", "action": "open_modal_age_calc" }],
      "checklist": [
        { "id": "toggle_single_rescuer", "label": "Are you a single rescuer?", "type": "boolean_toggle" },
        { "id": "chk_speakerphone", "label": "Call EMS on speakerphone", "type": "checkbox", "visible_if": "toggle_single_rescuer == true" },
        { "id": "chk_delay_call", "label": "Do CPR 1 min before leaving to call", "type": "checkbox", "visible_if": "toggle_single_rescuer == true AND chk_speakerphone == false" }
      ],
      "transitions": { "type": "linear", "next_id": "CARD_06_CHECK_LIFE_PRE_CPR" }
    },
    {
      "id": "CARD_06_CHECK_LIFE_PRE_CPR",
      "type": "decision",
      "content": { "title": "Signs of Life?", "body": "Were signs of life observed during rescue breaths?" },
      "wheel_config": { "position_degrees": 120, "phase": "check" },
      "transitions": {
        "type": "split",
        "options": [
          { "label": "YES", "target_id": "CARD_END_RECOVERY" },
          { "label": "NO", "target_id": "CARD_07_COMPRESSIONS" }
        ]
      }
    },
    {
      "id": "CARD_07_COMPRESSIONS",
      "type": "loop_start",
      "content": { "title": "30 Chest Compressions", "body": "Perform continuous chest compressions." },
      "wheel_config": { "position_degrees": 180, "phase": "cpr_loop", "animation": "pulse" },
      "local_timer": { "enabled": true, "type": "metronome", "bpm": 110, "guidance": "Push hard and fast" },
      "transitions": { "type": "linear", "next_id": "CARD_08_LOOP_BREATHS" }
    },
    {
      "id": "CARD_08_LOOP_BREATHS",
      "type": "action",
      "content": { "title": "2 Rescue Breaths", "body": "Deliver 2 effective breaths." },
      "wheel_config": { "position_degrees": 200, "phase": "cpr_loop" },
      "transitions": { "type": "linear", "next_id": "CARD_09_LOOP_CHECK" }
    },
    {
      "id": "CARD_09_LOOP_CHECK",
      "type": "decision",
      "content": { "title": "Re-assess", "body": "Are there clear signs of life?" },
      "wheel_config": { "position_degrees": 220, "phase": "cpr_loop" },
      "transitions": {
        "type": "split",
        "options": [
          { "label": "NO", "preview_card_title": "Resume Compressions", "target_id": "CARD_07_COMPRESSIONS" },
          { "label": "YES", "preview_card_title": "Recovery Position", "target_id": "CARD_END_RECOVERY" }
        ]
      }
    },
    {
      "id": "CARD_END_RECOVERY",
      "type": "terminal",
      "content": { "title": "Stabilised", "body": "Keep child in safe position, continue to assess and await EMS." },
      "wheel_config": { "position_degrees": 60, "phase": "complete" },
      "status": "complete"
    }
  ]
};

const PHASE_ANCHOR_RATIO = {
    start_point: 0.0,
    assessment: 0.12,
    action: 0.28,
    decision: 0.45,
    intervention: 0.62,
    check: 0.76,
    loop: 0.88,
    cpr_loop: 0.88,
    complete: 1.0,
};

const DEFAULT_WHEEL_ARC = {
    start_degrees: 330,
    end_degrees: 30,
    direction: 'anticlockwise',
    phase_spread_degrees: 4,
};

const DEFAULT_ALGORITHM_FILES = [
    'algo_paed_bls_out.json',
    'algo_paed_bls_in.json',
    'algo_newborn_ls.json',
    'algo_anaphylaxis.json',
    'algo_paed_fbao.json',
];

let RUNTIME_ALGORITHM = JSON.parse(JSON.stringify(DEFAULT_ALGORITHM));
let ACTIVE_ALGORITHM_SOURCE = 'inline-default';
const DECK = {};

function deepClone(value) {
    return JSON.parse(JSON.stringify(value));
}

function normalizeDegrees(deg) {
    const n = Number(deg);
    if (!Number.isFinite(n)) return 0;
    const mod = n % 360;
    return mod < 0 ? mod + 360 : mod;
}

function normalizeWheelArc(rawMeta) {
    const raw = rawMeta && rawMeta.wheel_arc ? rawMeta.wheel_arc : {};
    const direction = String(raw.direction || DEFAULT_WHEEL_ARC.direction).toLowerCase() === 'anticlockwise'
        ? 'anticlockwise'
        : 'clockwise';
    const start = Number.isFinite(Number(raw.start_degrees))
        ? normalizeDegrees(Number(raw.start_degrees))
        : DEFAULT_WHEEL_ARC.start_degrees;
    const end = Number.isFinite(Number(raw.end_degrees))
        ? normalizeDegrees(Number(raw.end_degrees))
        : DEFAULT_WHEEL_ARC.end_degrees;
    const spread = Number.isFinite(Number(raw.phase_spread_degrees))
        ? Math.max(0, Number(raw.phase_spread_degrees))
        : DEFAULT_WHEEL_ARC.phase_spread_degrees;
    return {
        start_degrees: start,
        end_degrees: end,
        direction,
        phase_spread_degrees: spread,
    };
}

function angleOnArc(arc, ratio) {
    const t = Math.max(0, Math.min(1, Number(ratio)));
    const cwDistance = (arc.end_degrees - arc.start_degrees + 360) % 360;
    const ccwDistance = (arc.start_degrees - arc.end_degrees + 360) % 360;
    if (arc.direction === 'anticlockwise') {
        return normalizeDegrees(arc.start_degrees - ccwDistance * t);
    }
    return normalizeDegrees(arc.start_degrees + cwDistance * t);
}

function inferPhase(card) {
    const explicit = card && card.wheel_config && card.wheel_config.phase
        ? String(card.wheel_config.phase).trim()
        : '';
    if (explicit) {
        if (explicit === 'cpr_loop') return 'loop';
        return explicit;
    }
    if (!card || !card.type) return 'action';
    if (card.type === 'cover') return 'start_point';
    if (card.type === 'decision') return 'decision';
    if (card.type === 'terminal') return 'complete';
    if (card.type === 'loop_start') return 'loop';
    return 'action';
}

function normalizeTransitions(card, index, cards) {
    const raw = card && card.transitions ? card.transitions : null;
    const isTerminalLike = card
        && (card.type === 'terminal'
        || card.status === 'complete'
        || card.status === 'handoff');

    if (!raw) {
        if (isTerminalLike) return null;
        const nextCard = cards[index + 1];
        return nextCard ? { type: 'linear', next_id: nextCard.id } : null;
    }

    if (raw.type === 'split' && Array.isArray(raw.options)) {
        const options = raw.options
            .filter((opt) => opt && opt.target_id)
            .map((opt, idx) => ({
                label: opt.label || `Option ${idx + 1}`,
                sub_label: opt.sub_label || null,
                preview_card_title: opt.preview_card_title || null,
                target_id: String(opt.target_id),
            }));
        if (options.length > 0) return { type: 'split', options };
    }

    if (raw.type === 'self_loop') {
        return {
            type: 'self_loop',
            next_id: raw.next_id ? String(raw.next_id) : String(card.id),
        };
    }

    const linearNext = raw.next_id
        ? String(raw.next_id)
        : (!isTerminalLike && cards[index + 1] ? String(cards[index + 1].id) : null);
    if (linearNext) {
        return { type: 'linear', next_id: linearNext };
    }

    return null;
}

function derivePositionDegrees(cards, arc) {
    const byPhase = {};
    cards.forEach((card) => {
        const phase = card.wheel_config.phase;
        if (!byPhase[phase]) byPhase[phase] = [];
        byPhase[phase].push(card.id);
    });

    const phaseIndex = {};
    for (const [phase, ids] of Object.entries(byPhase)) {
        ids.forEach((id, idx) => {
            phaseIndex[id] = { idx, count: ids.length };
        });
    }

    cards.forEach((card) => {
        const rawPos = card.wheel_config && typeof card.wheel_config.position_degrees === 'number'
            ? card.wheel_config.position_degrees
            : null;
        if (rawPos != null) {
            card.wheel_config.position_degrees = normalizeDegrees(rawPos);
            return;
        }

        const phase = card.wheel_config.phase;
        const ratio = Object.prototype.hasOwnProperty.call(PHASE_ANCHOR_RATIO, phase)
            ? PHASE_ANCHOR_RATIO[phase]
            : PHASE_ANCHOR_RATIO.action;
        const anchor = angleOnArc(arc, ratio);
        const placement = phaseIndex[card.id] || { idx: 0, count: 1 };
        const spread = arc.phase_spread_degrees;
        const localOffset = placement.count <= 1
            ? 0
            : ((placement.idx / (placement.count - 1)) - 0.5) * spread;
        const signedOffset = arc.direction === 'anticlockwise' ? -localOffset : localOffset;
        card.wheel_config.position_degrees = normalizeDegrees(anchor + signedOffset);
    });
}

function normalizeAlgorithm(rawAlgorithm) {
    const raw = rawAlgorithm && typeof rawAlgorithm === 'object' ? rawAlgorithm : deepClone(DEFAULT_ALGORITHM);
    const meta = raw.algorithm_meta && typeof raw.algorithm_meta === 'object'
        ? deepClone(raw.algorithm_meta)
        : {};
    const arc = normalizeWheelArc(meta);
    const rawDeck = Array.isArray(raw.deck) ? raw.deck : [];
    const cards = rawDeck
        .filter((card) => card && typeof card === 'object' && card.id)
        .map((card) => ({
            ...deepClone(card),
            id: String(card.id),
            content: card.content && typeof card.content === 'object' ? deepClone(card.content) : { title: String(card.id), body: '' },
            checklist: Array.isArray(card.checklist) ? deepClone(card.checklist) : [],
            wheel_config: card.wheel_config && typeof card.wheel_config === 'object' ? deepClone(card.wheel_config) : {},
        }));

    cards.forEach((card, idx) => {
        card.wheel_config.phase = inferPhase(card);
        card.transitions = normalizeTransitions(card, idx, cards);
    });
    derivePositionDegrees(cards, arc);

    meta.wheel_arc = arc;
    return {
        algorithm_meta: meta,
        deck: cards,
    };
}

function rebuildDeckMap(cards) {
    Object.keys(DECK).forEach((key) => {
        delete DECK[key];
    });
    cards.forEach((card) => {
        DECK[card.id] = card;
    });
}

function currentAlgorithmStartId() {
    return RUNTIME_ALGORITHM.deck.length > 0 ? RUNTIME_ALGORITHM.deck[0].id : null;
}

function syncHeaderFromAlgorithm() {
    const titleEl = document.querySelector('.app-title');
    if (!titleEl) return;
    const title = RUNTIME_ALGORITHM && RUNTIME_ALGORITHM.algorithm_meta
        ? RUNTIME_ALGORITHM.algorithm_meta.title
        : '';
    titleEl.textContent = title || 'Resuscitation Handbook';
}

function applyAlgorithm(rawAlgorithm, sourceLabel) {
    RUNTIME_ALGORITHM = normalizeAlgorithm(rawAlgorithm);
    ACTIVE_ALGORITHM_SOURCE = sourceLabel || 'inline-default';
    rebuildDeckMap(RUNTIME_ALGORITHM.deck);
    state.currentId = currentAlgorithmStartId();
    state.history = [];
    state.decisionIndex = 0;
    state.decisionRecords = {};
    state.decisionTrail = [];
    state.decisionTapped = false;
    state.carouselIndex = 0;
    state.checklistState = {};
    state.anchors = [];
    state.anchorIndex = 0;
    state.wheel.dragOrigin = null;
    state.wheel.navConsumed = false;

    if (state.currentId && DECK[state.currentId]) {
        state.wheel.mode = computeWheelMode(DECK[state.currentId]);
    } else {
        state.wheel.mode = 'LINEAR';
    }
    // Anchor angle will be set by render() → syncAnchors()
    state.wheel.angle = 330;

    resetTimerState();
    syncHeaderFromAlgorithm();
    render();
    return {
        ok: true,
        source: sourceLabel || 'inline-default',
        algorithm_id: RUNTIME_ALGORITHM.algorithm_meta && RUNTIME_ALGORITHM.algorithm_meta.id
            ? RUNTIME_ALGORITHM.algorithm_meta.id
            : null,
        card_count: RUNTIME_ALGORITHM.deck.length,
    };
}

function sanitizeAlgorithmFile(value) {
    const text = String(value || '').trim();
    if (!text) return null;
    if (!/^[a-zA-Z0-9._-]+\.json$/.test(text)) return null;
    return text;
}

async function discoverAvailableAlgorithmFiles() {
    try {
        const res = await fetch('algorithms/index.json', { cache: 'no-store' });
        if (!res.ok) return [...DEFAULT_ALGORITHM_FILES];
        const payload = await res.json();
        if (!payload || !Array.isArray(payload.algorithms)) return [...DEFAULT_ALGORITHM_FILES];
        const files = payload.algorithms
            .map((row) => sanitizeAlgorithmFile(row && row.file))
            .filter(Boolean);
        if (files.length === 0) return [...DEFAULT_ALGORITHM_FILES];
        return Array.from(new Set(files));
    } catch {
        return [...DEFAULT_ALGORITHM_FILES];
    }
}

async function loadAlgorithmByFileName(fileName) {
    const safe = sanitizeAlgorithmFile(fileName);
    if (!safe) throw new Error(`Invalid algorithm file: ${fileName}`);
    const res = await fetch(`algorithms/${safe}`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Failed to load algorithms/${safe} (HTTP ${res.status})`);
    return res.json();
}

async function initAlgorithmFromUrl() {
    const params = new URLSearchParams(window.location.search);
    const requested = sanitizeAlgorithmFile(params.get('algo'));
    if (requested) {
        try {
            const loaded = await loadAlgorithmByFileName(requested);
            applyAlgorithm(loaded, requested);
            return;
        } catch (err) {
            console.error(err);
        }
    }

    try {
        const available = await discoverAvailableAlgorithmFiles();
        const preferred = DEFAULT_ALGORITHM_FILES.find((file) => available.includes(file))
            || available[0]
            || null;
        if (preferred) {
            const loaded = await loadAlgorithmByFileName(preferred);
            applyAlgorithm(loaded, preferred);
            return;
        }
    } catch (err) {
        console.error(err);
    }

    applyAlgorithm(DEFAULT_ALGORITHM, 'inline-default-fallback');
}

// ========================================
// STATE
// ========================================
let state = {
    currentId: "CARD_00_START",
    history: [],
    decisionIndex: 0,
    decisionRecords: {},
    decisionTrail: [],
    decisionTapped: false,
    carouselIndex: 0,
    timerSeconds: 0,
    timerRunning: false,
    timerInterval: null,
    checklistState: {},  // Track checkbox states

    // Anchor-point navigation state
    anchors: [],                 // Array of {id, angle} — one per card in current path
    anchorIndex: 0,              // Index into anchors[] for current card

    // Wheel state (FSM)
    wheel: {
        mode: "COVER",           // COVER | LINEAR | DECISION | LOOP | TERMINAL
        angle: 330,              // Knob angle — always reflects current anchor
        dragOrigin: null,        // Angle at the start of current drag gesture
        navConsumed: false       // One navigation transition per drag gesture
    }
};

// ========================================
// DOM REFERENCES
// ========================================
const zoneTop = document.getElementById('zone-top');
const zoneBottom = document.getElementById('zone-bottom');
const activeCard = document.getElementById('active-card');
const knob = document.getElementById('knob');
const wheel = document.getElementById('wheel');
const checklistArea = document.getElementById('checklist-area');
const timerEl = document.getElementById('timer');
const modalOverlay = document.getElementById('modal-overlay');

// ========================================
// WHEEL PHYSICS
// ========================================
const WHEEL_RADIUS = 150;
const KNOB_OFFSET = 15; // Half of knob size
const NAV_THRESHOLD_DEG = 10;        // Small intent → one step (forward/reverse)

function degToPosition(deg) {
    const mathDeg = deg - 90; // Convert: 0° top → 0° right
    const rad = mathDeg * (Math.PI / 180);
    return {
        x: WHEEL_RADIUS + WHEEL_RADIUS * Math.cos(rad) - KNOB_OFFSET,
        y: WHEEL_RADIUS + WHEEL_RADIUS * Math.sin(rad) - KNOB_OFFSET
    };
}

function setKnobPosition(deg) {
    const pos = degToPosition(deg);
    const zoneMiddle = document.getElementById('zone-middle');
    const offsetX = (zoneMiddle.offsetWidth - 300) / 2;
    const offsetY = (zoneMiddle.offsetHeight - 300) / 2;
    knob.style.left = (offsetX + pos.x) + 'px';
    knob.style.top = (offsetY + pos.y) + 'px';
}

// ========================================
// WHEEL STATE HELPERS (FSM + angle logic)
// ========================================
function computeWheelMode(card) {
    if (!card) return "LINEAR";
    if (card.type === "cover") return "COVER";
    if (card.type === "decision") return "DECISION";
    if (card.type === "terminal") return "TERMINAL";
    if (card.wheel_config && (card.wheel_config.phase === "cpr_loop" || card.wheel_config.phase === "loop")) return "LOOP";
    return "LINEAR";
}

function canonicalAngleForCard(card, fallbackAngle) {
    if (card && card.wheel_config && typeof card.wheel_config.position_degrees === "number") {
        return card.wheel_config.position_degrees;
    }
    return typeof fallbackAngle === "number" ? fallbackAngle : 330;
}

// Wrap-safe delta between two angles (design degrees, 0–360)
function angleDelta(fromDeg, toDeg) {
    let delta = fromDeg - toDeg;
    if (delta > 180) delta -= 360;
    if (delta < -180) delta += 360;
    return delta;
}

function getCurrentWheelArc() {
    const meta = RUNTIME_ALGORITHM && RUNTIME_ALGORITHM.algorithm_meta
        ? RUNTIME_ALGORITHM.algorithm_meta
        : null;
    return normalizeWheelArc(meta);
}

function isAngleWithinArc(angle, arc) {
    const deg = normalizeDegrees(angle);
    if (arc.direction === 'anticlockwise') {
        const ccwDistance = (arc.start_degrees - arc.end_degrees + 360) % 360;
        const ccwFromStart = (arc.start_degrees - deg + 360) % 360;
        return ccwFromStart <= ccwDistance;
    }
    const cwDistance = (arc.end_degrees - arc.start_degrees + 360) % 360;
    const cwFromStart = (deg - arc.start_degrees + 360) % 360;
    return cwFromStart <= cwDistance;
}

function shortestAngularDistance(a, b) {
    const nA = normalizeDegrees(a);
    const nB = normalizeDegrees(b);
    const diff = Math.abs(nA - nB);
    return Math.min(diff, 360 - diff);
}

function clampAngleToArc(angle, arc) {
    const deg = normalizeDegrees(angle);
    if (isAngleWithinArc(deg, arc)) return deg;
    const startDist = shortestAngularDistance(deg, arc.start_degrees);
    const endDist = shortestAngularDistance(deg, arc.end_degrees);
    return startDist <= endDist ? arc.start_degrees : arc.end_degrees;
}

function isForwardGesture(delta, arc, threshold) {
    // angleDelta > 0 means anticlockwise movement; < 0 means clockwise movement.
    var t = typeof threshold === 'number' ? threshold : NAV_THRESHOLD_DEG;
    if (arc.direction === 'anticlockwise') {
        return delta > t;
    }
    return delta < -t;
}

function isReverseGesture(delta, arc, threshold) {
    var t = typeof threshold === 'number' ? threshold : NAV_THRESHOLD_DEG;
    if (arc.direction === 'anticlockwise') {
        return delta < -t;
    }
    return delta > t;
}

function isSplitDecisionCard(card) {
    return !!(
        card
        && card.transitions
        && card.transitions.type === 'split'
        && Array.isArray(card.transitions.options)
        && card.transitions.options.length > 0
    );
}

function rememberedDecisionIndexForCard(card) {
    if (!isSplitDecisionCard(card)) return 0;
    const remembered = Object.prototype.hasOwnProperty.call(state.decisionRecords, card.id)
        ? state.decisionRecords[card.id]
        : state.decisionIndex;
    return normalizeDecisionIndexForCard(card, remembered);
}

// ========================================
// ANCHOR-POINT NAVIGATION ENGINE
// ========================================

/**
 * Count how many cards a branch reaches from a starting card (non-destructive).
 * Used to pick the longest branch for progress estimation.
 */
function countPathLength(startId, alreadyVisited) {
    var count = 0;
    var cardId = startId;
    var visited = new Set(alreadyVisited);
    while (cardId && DECK[cardId] && !visited.has(cardId)) {
        visited.add(cardId);
        count++;
        var card = DECK[cardId];
        if (!card.transitions) break;
        if (card.transitions.type === 'linear') {
            cardId = card.transitions.next_id;
        } else if (card.transitions.type === 'split') {
            // For estimation depth, follow first option
            cardId = card.transitions.options[0] ? card.transitions.options[0].target_id : null;
        } else if (card.transitions.type === 'self_loop') {
            if (card.transitions.next_id === card.id) break;
            cardId = card.transitions.next_id;
        } else {
            break;
        }
    }
    return count;
}

/**
 * Pick the branch target that leads to the longest remaining path.
 * This ensures progress only jumps forward (toward completion) after a decision.
 */
function longestBranchTarget(card, visited) {
    if (!card.transitions || card.transitions.type !== 'split') return null;
    var bestTarget = null;
    var bestLength = -1;
    for (var i = 0; i < card.transitions.options.length; i++) {
        var opt = card.transitions.options[i];
        if (!opt.target_id || !DECK[opt.target_id]) continue;
        if (visited.has(opt.target_id)) continue;
        var len = countPathLength(opt.target_id, visited);
        if (len > bestLength) {
            bestLength = len;
            bestTarget = opt.target_id;
        }
    }
    return bestTarget || (card.transitions.options[0] ? card.transitions.options[0].target_id : null);
}

/**
 * Walk the algorithm from start, following transitions and recorded decisions.
 * For unrecorded decisions, follows the LONGEST branch so progress only
 * jumps forward (toward completion) after a decision, never backward.
 * Returns ordered array of card IDs representing the current projected path.
 */
function computeForwardPath() {
    const path = [];
    const visited = new Set();
    let cardId = currentAlgorithmStartId();

    while (cardId && DECK[cardId] && !visited.has(cardId)) {
        visited.add(cardId);
        path.push(cardId);

        const card = DECK[cardId];
        if (!card.transitions) break;

        if (card.transitions.type === 'linear') {
            cardId = card.transitions.next_id;
        } else if (card.transitions.type === 'split') {
            if (Object.prototype.hasOwnProperty.call(state.decisionRecords, card.id)) {
                // Follow the committed decision
                const idx = state.decisionRecords[card.id];
                const opt = card.transitions.options[idx];
                cardId = opt ? opt.target_id : null;
            } else {
                // No decision recorded — follow longest branch for stable progress
                cardId = longestBranchTarget(card, visited);
            }
        } else if (card.transitions.type === 'self_loop') {
            const nextId = card.transitions.next_id;
            if (nextId === card.id) break;
            cardId = nextId;
        } else {
            break;
        }
    }

    return path;
}

/**
 * Compute anchor angles: evenly distribute path cards across the wheel arc.
 * Returns array of {id, angle} pairs.
 */
function computeAnchors() {
    const path = computeForwardPath();
    const arc = getCurrentWheelArc();

    if (path.length === 0) return [];
    if (path.length === 1) {
        return [{ id: path[0], angle: arc.start_degrees }];
    }

    return path.map((id, i) => ({
        id,
        angle: angleOnArc(arc, i / (path.length - 1)),
    }));
}

/**
 * Find the anchor index for a given card ID. Returns -1 if not found.
 */
function findAnchorIndex(cardId) {
    return state.anchors.findIndex(function (a) { return a.id === cardId; });
}

/**
 * Get the angle for the current anchor position.
 */
function currentAnchorAngle() {
    if (state.anchorIndex >= 0 && state.anchorIndex < state.anchors.length) {
        return state.anchors[state.anchorIndex].angle;
    }
    return getCurrentWheelArc().start_degrees;
}

/**
 * Recalculate anchors from the algorithm and sync anchorIndex to current card.
 */
function syncAnchors() {
    state.anchors = computeAnchors();
    var idx = findAnchorIndex(state.currentId);
    if (idx >= 0) {
        state.anchorIndex = idx;
    } else {
        // Current card not in computed path — use last anchor
        state.anchorIndex = Math.max(0, state.anchors.length - 1);
    }
}

// ========================================
// RENDER ENGINE
// ========================================
function render() {
    const card = DECK[state.currentId];
    if (!card) return;

    // 1. Derive wheel mode for this card
    state.wheel.mode = computeWheelMode(card);

    // 2. Anchor-point model: recalculate anchors and snap knob
    syncAnchors();
    state.wheel.angle = currentAnchorAngle();
    setKnobPosition(state.wheel.angle);

    // 3. Continue with existing rendering pipeline
    renderActiveCard(card);
    renderPreviewZone(card);
    renderHistoryZone();
    renderChecklist(card);

    // 4. Update ARIA
    knob.setAttribute('aria-valuetext', card.content.title);
    knob.setAttribute('aria-valuenow', state.anchorIndex);
    knob.setAttribute('aria-valuemax', state.anchors.length);
}

function renderActiveCard(card) {
    // Reset classes
    activeCard.className = '';
    
    // Cover mode (transparent, no border)
    if (card.type === 'cover') {
        activeCard.classList.add('cover-mode');
    }
    
    // Loop animation (pulse red)
    if (card.wheel_config.animation === 'pulse' || card.type === 'loop_start') {
        activeCard.classList.add('loop-mode');
    }
    
    let html = '';
    
    if (card.type === 'cover') {
        html = `
            <div class="cover-content">
                <div class="cover-title">${card.content.title}</div>
                <div class="cover-subtitle">${card.content.subtitle || ''}</div>
            </div>
        `;
    } else {
        // Standard card with icons
        const hasToolbox = card.toolbox && card.toolbox.length > 0;
        const hasSlides = card.content.slides && card.content.slides.length > 1;
        
        html = `
            <svg class="card-icon icon-tr" onclick="openFullscreen()"><use href="#icon-fullscreen"/></svg>
            ${hasToolbox ? '<svg class="card-icon icon-bl" onclick="openToolbox()"><use href="#icon-toolbox"/></svg>' : ''}
            
            <div class="card-header">${card.type.replace('_', ' ')}</div>
            <div class="card-title">${card.content.title}</div>
            <div class="card-body">${getCardBodyContent(card)}</div>
            
            ${hasSlides ? renderCarouselDots(card.content.slides.length) : ''}
        `;
    }
    
    activeCard.innerHTML = html;
}

function getCardBodyContent(card) {
    // If carousel with slides, show current slide
    if (card.content.slides && card.content.slides.length > 0) {
        if (card.type === 'carousel_action' && card.content.slides.length > 1) {
            const slide = card.content.slides[state.carouselIndex] || card.content.slides[0];
            return `<strong>${slide.header || slide.label}</strong><br>${slide.text}`;
        } else if (card.content.slides[0]) {
            const slide = card.content.slides[0];
            return slide.text || card.content.body || '';
        }
    }
    return card.content.body || '';
}

function renderCarouselDots(count) {
    let dots = '';
    for (let i = 0; i < count; i++) {
        dots += `<div class="dot ${i === state.carouselIndex ? 'active' : ''}"></div>`;
    }
    return `<div class="carousel-dots">${dots}</div>`;
}

function renderPreviewZone(card) {
    zoneTop.innerHTML = '';
    zoneTop.classList.remove('decision-mode');
    
    // DECISION MODE: Two options side-by-side with preview stacks
    if (card.type === 'decision' && card.transitions.type === 'split') {
        zoneTop.classList.add('decision-mode');
        
        const options = card.transitions.options;
        
        options.forEach((opt, idx) => {
            const isSelected = state.decisionTapped && idx === state.decisionIndex;
            
            // Create option container (holds the option card + its preview stack)
            const optContainer = document.createElement('div');
            optContainer.className = `decision-option-container ${isSelected ? 'selected' : ''}`;
            optContainer.dataset.optionIndex = idx;
            
            // Get preview cards for THIS option's path
            const targetCard = DECK[opt.target_id];
            const previewStack = targetCard ? getUpcomingCardsFrom(opt.target_id, 3) : [];
            
            // Render preview stack behind (only for selected option)
            if (isSelected && previewStack.length > 0) {
                previewStack.reverse().forEach((pc, pi) => {
                    const depth = previewStack.length - pi;
                    const stackCard = document.createElement('div');
                    stackCard.className = 'card preview-stack-card';
                    stackCard.style.transform = `translateY(${-depth * 8}px) scale(${1 - depth * 0.04})`;
                    stackCard.style.zIndex = 5 - depth;
                    stackCard.innerHTML = `<div class="card-header small">${pc.content.title}</div>`;
                    optContainer.appendChild(stackCard);
                });
            }
            
            // Render main option card (on top)
            const optCard = document.createElement('div');
            optCard.className = `card decision-option-card ${isSelected ? 'selected' : ''}`;
            optCard.style.zIndex = 10;
            optCard.innerHTML = `
                <div class="card-header">${card.content.title}</div>
                <div class="card-body small">${card.content.body}</div>
                <div class="option-badge">${opt.label}</div>
            `;
            
            // Click to select this option
            optCard.onclick = (e) => {
                e.stopPropagation();
                selectDecisionOption(idx);
            };
            
            optContainer.appendChild(optCard);
            zoneTop.appendChild(optContainer);
        });
        
        // Setup drag handling for decision cards
        setupDecisionDrag();
        return;
    }
    
    // LINEAR MODE: Vertical stack
    const upcoming = getUpcomingCards(card, 3);
    upcoming.reverse().forEach((c, i) => {
        const depth = upcoming.length - 1 - i;
        const el = document.createElement('div');
        el.className = 'card preview-card';
        el.style.transform = `translateY(${depth * -10}px) scale(${1 - depth * 0.05})`;
        el.style.zIndex = 10 - depth;
        
        let iconHtml = '';
        if (c.type === 'decision') {
            iconHtml = '<svg class="decision-indicator"><use href="#icon-decision"/></svg>';
        }
        
        el.innerHTML = `
            ${iconHtml}
            <div class="card-header">${c.content.title}</div>
        `;
        
        zoneTop.appendChild(el);
    });
}

// Get upcoming cards starting FROM a specific card ID
function getUpcomingCardsFrom(startId, max) {
    const result = [];
    let currentId = startId;
    
    while (currentId && result.length < max && DECK[currentId]) {
        const currentCard = DECK[currentId];
        result.push(currentCard);
        
        if (currentCard.transitions?.next_id) {
            currentId = currentCard.transitions.next_id;
        } else if (currentCard.transitions?.options) {
            currentId = currentCard.transitions.options[0].target_id;
        } else {
            break;
        }
    }
    return result;
}

function getUpcomingCards(card, max) {
    let nextId = card.transitions?.next_id;
    
    // For splits, use first option as preview path
    if (card.transitions?.type === 'split' && card.transitions.options) {
        nextId = card.transitions.options[0].target_id;
    }
    
    return nextId ? getUpcomingCardsFrom(nextId, max) : [];
}

// ========================================
// DECISION DRAG-TO-CONFIRM (Mouse + Touch)
// ========================================
let isDraggingDecision = false;
let draggedElement = null;
let dragStartY = 0;
let dragStartX = 0;
let originalTransform = '';

function setupDecisionDrag() {
    const optionCards = zoneTop.querySelectorAll('.decision-option-card.selected');
    optionCards.forEach(card => {
        card.addEventListener('mousedown', startDecisionDrag);
        card.addEventListener('touchstart', startDecisionDrag, { passive: false });
    });
}

function startDecisionDrag(e) {
    const card = DECK[state.currentId];
    if (card.type !== 'decision') return;
    
    isDraggingDecision = true;
    draggedElement = e.currentTarget;
    originalTransform = draggedElement.style.transform;
    
    const touch = e.touches ? e.touches[0] : e;
    dragStartY = touch.clientY;
    dragStartX = touch.clientX;
    
    e.preventDefault();
    e.stopPropagation();
    
    document.addEventListener('mousemove', onDecisionDrag);
    document.addEventListener('touchmove', onDecisionDrag, { passive: false });
    document.addEventListener('mouseup', endDecisionDrag);
    document.addEventListener('touchend', endDecisionDrag);
}

function onDecisionDrag(e) {
    if (!isDraggingDecision || !draggedElement) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    const dy = touch.clientY - dragStartY;
    const dx = touch.clientX - dragStartX;
    
    // Visual feedback: move card with cursor
    draggedElement.style.transform = `translate(${dx}px, ${dy}px) scale(1.05)`;
    draggedElement.style.zIndex = 100;
    draggedElement.style.boxShadow = '0 20px 40px rgba(0,0,0,0.3)';
    
    // Highlight middle zone if dragging toward it
    if (dy > 30) {
        activeCard.style.outline = '3px dashed #666';
    } else {
        activeCard.style.outline = 'none';
    }
}

function endDecisionDrag(e) {
    if (!isDraggingDecision) return;
    
    document.removeEventListener('mousemove', onDecisionDrag);
    document.removeEventListener('touchmove', onDecisionDrag);
    document.removeEventListener('mouseup', endDecisionDrag);
    document.removeEventListener('touchend', endDecisionDrag);
    
    const touch = e.changedTouches ? e.changedTouches[0] : e;
    const dy = touch.clientY - dragStartY;
    
    // Reset middle zone highlight
    activeCard.style.outline = 'none';
    
    // If dragged down enough and an option was tapped, confirm the decision
    if (dy > 60 && state.decisionTapped) {
        advance({ source: 'decision-confirm', splitConfirmed: true });
    } else {
        // Snap back
        if (draggedElement) {
            draggedElement.style.transform = originalTransform || '';
            draggedElement.style.zIndex = 10;
            draggedElement.style.boxShadow = '';
        }
    }
    
    isDraggingDecision = false;
    draggedElement = null;
}

function renderHistoryZone() {
    zoneBottom.innerHTML = '';
    
    const recent = state.history.slice(-3);
    recent.forEach((id, i, arr) => {
        const c = DECK[id];
        if (!c) return;
        
        const depth = arr.length - 1 - i;
        const el = document.createElement('div');
        el.className = 'card history-card';
        el.style.transform = `translateY(${depth * 8}px) scale(${1 - depth * 0.06})`;
        el.style.zIndex = 10 - depth;
        el.innerHTML = `<div class="card-header">${c.content.title}</div>`;
        zoneBottom.appendChild(el);
    });
}

function renderChecklist(card) {
    checklistArea.innerHTML = '';
    
    if (!card.checklist) return;
    
    card.checklist.forEach(item => {
        const el = document.createElement('label');
        el.className = `check-item ${item.type === 'boolean_toggle' ? 'toggle-item' : ''}`;
        
        // Check visibility
        if (item.visible_if) {
            const visible = evaluateVisibility(item.visible_if);
            if (!visible) el.classList.add('hidden');
        }
        
        const checked = state.checklistState[item.id] ? 'checked' : '';
        el.innerHTML = `
            <input type="checkbox" ${checked} onchange="handleCheckChange('${item.id}', '${item.type}', this.checked)">
            <span>${item.label}</span>
        `;
        checklistArea.appendChild(el);
    });
}

function evaluateVisibility(condition) {
    // Simple parser for "toggle_id == true" or "toggle_id == true AND other == false"
    const parts = condition.split(' AND ');
    return parts.every(part => {
        const match = part.trim().match(/(\w+)\s*==\s*(true|false)/);
        if (match) {
            const [, id, expected] = match;
            const actual = !!state.checklistState[id];
            return actual === (expected === 'true');
        }
        return true;
    });
}

function handleCheckChange(id, type, checked) {
    state.checklistState[id] = checked;
    
    // Re-render checklist to update visibility
    const card = DECK[state.currentId];
    renderChecklist(card);
}

// ========================================
// NAVIGATION
// ========================================
function advance(options = {}) {
    const opts = options && typeof options === 'object' ? options : {};
    const source = opts.source || 'ui';
    const splitConfirmed = Boolean(opts.splitConfirmed || source === 'automation');
    const card = DECK[state.currentId];
    
    if (!card || card.status === 'complete') return false;
    
    let nextId = null;

    if (!card.transitions || !card.transitions.type) {
        return false;
    }

    if (card.transitions.type === 'linear') {
        nextId = card.transitions.next_id;
    } else if (card.transitions.type === 'split') {
        if (!Array.isArray(card.transitions.options) || card.transitions.options.length === 0) return false;
        if (!splitConfirmed) return false;
        const pickedIndex = normalizeDecisionIndexForCard(card, state.decisionIndex);
        const picked = card.transitions.options[pickedIndex] || null;
        nextId = picked ? picked.target_id : null;
        state.decisionRecords[card.id] = pickedIndex;
        state.decisionTrail.push({
            card_id: card.id,
            option_index: pickedIndex,
            option_label: picked && picked.label ? picked.label : `Option ${pickedIndex + 1}`,
            target_id: nextId || null,
            interaction: 'forward-decision-confirm',
            source,
            timestamp: new Date().toISOString(),
        });
    } else if (card.transitions.type === 'self_loop') {
        nextId = card.transitions.next_id || card.id;
    }

    if (nextId && DECK[nextId]) {
        if (nextId !== state.currentId) {
            state.history.push(state.currentId);
        }
        state.currentId = nextId;
        const nextCard = DECK[nextId];
        if (isSplitDecisionCard(nextCard)) {
            state.decisionIndex = rememberedDecisionIndexForCard(nextCard);
        } else {
            state.decisionIndex = 0;
        }
        state.decisionTapped = false;
        state.carouselIndex = 0;

        const autoStartCard = RUNTIME_ALGORITHM
            && RUNTIME_ALGORITHM.algorithm_meta
            && RUNTIME_ALGORITHM.algorithm_meta.global_timer
            ? RUNTIME_ALGORITHM.algorithm_meta.global_timer.auto_start_on_card
            : null;
        const shouldStartTimer = !autoStartCard || nextId === autoStartCard;
        if (!state.timerRunning && shouldStartTimer) startTimer();
        
        render();
        return true;
    }
    return false;
}

function rewind() {
    if (state.history.length <= 0) return false;
    const prevId = state.history.pop();
    state.currentId = prevId;
    const prevCard = DECK[prevId];
    if (isSplitDecisionCard(prevCard)) {
        state.decisionIndex = rememberedDecisionIndexForCard(prevCard);
        state.decisionTapped = Object.prototype.hasOwnProperty.call(state.decisionRecords, prevId);
    } else {
        state.decisionIndex = 0;
        state.decisionTapped = false;
    }
    state.carouselIndex = 0;

    render();
    return true;
}

function selectDecisionOption(idx) {
    const card = DECK[state.currentId];
    state.decisionIndex = normalizeDecisionIndexForCard(card, idx);
    state.decisionTapped = true;
    render();
}

// ========================================
// DRAG HANDLING - WHEEL (FSM-Driven)
// ========================================
let isDraggingKnob = false;

knob.addEventListener('mousedown', startKnobDrag);
knob.addEventListener('touchstart', startKnobDrag, { passive: false });
document.addEventListener('mousemove', onKnobDrag);
document.addEventListener('touchmove', onKnobDrag, { passive: false });
document.addEventListener('mouseup', endKnobDrag);
document.addEventListener('touchend', endKnobDrag);

// Convert pointer event → design angle (0° at top, clockwise)
function getAngleFromEvent(e) {
    const touch = e.touches ? e.touches[0] : e;
    const rect = wheel.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    let deg = Math.atan2(touch.clientY - cy, touch.clientX - cx) * 180 / Math.PI + 90;
    if (deg < 0) deg += 360;
    return deg;
}

function startKnobDrag(e) {
    isDraggingKnob = true;
    knob.classList.add('dragging');  // Disable CSS transition — knob tracks finger
    e.preventDefault();
    e.stopPropagation();

    const arc = getCurrentWheelArc();
    const startAngle = clampAngleToArc(getAngleFromEvent(e), arc);
    state.wheel.dragOrigin = startAngle;
    state.wheel.navConsumed = false;
    // Knob stays at anchor — don't change state.wheel.angle here
}

function triggerHaptic(ms) {
    if (navigator.vibrate) navigator.vibrate(ms);
}

function handleDecisionWheelDrag(card, delta, currentAngle, arc) {
    if (!card.transitions || card.transitions.type !== 'split') {
        return;
    }

    // Reverse gesture: rewind out of decision card (always works, no tap needed)
    if (isReverseGesture(delta, arc)) {
        knob.classList.remove('dragging');  // Enable transition -> smooth snap
        const moved = rewind();
        if (moved) {
            state.wheel.navConsumed = true;
            triggerHaptic(15);
        }
        return;
    }

    // Forward gesture: confirm selected option and advance (only if tapped)
    if (state.decisionTapped && isForwardGesture(delta, arc)) {
        knob.classList.remove('dragging');  // Enable transition -> smooth snap
        const moved = advance({ source: 'wheel-drag', splitConfirmed: true });
        if (moved) {
            state.wheel.navConsumed = true;
            triggerHaptic(15);
        }
    }
    // Knob stays locked at anchor position — no visual movement
}

function onKnobDrag(e) {
    if (!isDraggingKnob) return;
    e.preventDefault();

    const card = DECK[state.currentId];
    if (!card) return;

    const arc = getCurrentWheelArc();
    const currentAngle = clampAngleToArc(getAngleFromEvent(e), arc);

    if (state.wheel.dragOrigin == null) {
        state.wheel.dragOrigin = currentAngle;
    }

    const delta = angleDelta(state.wheel.dragOrigin, currentAngle);

    const mode = state.wheel.mode;

    // Allow only one navigation transition per knob drag.
    // Knob already at new anchor — don't fight the CSS transition.
    if (state.wheel.navConsumed) {
        return;
    }

    // --- Mode: COVER (start screen) → forward gesture advances ---
    if (mode === "COVER") {
        if (isForwardGesture(delta, arc)) {
            knob.classList.remove('dragging');  // Enable transition -> smooth snap
            advance({ source: 'wheel-drag' });
            state.wheel.navConsumed = true;
            triggerHaptic(15);
        } else {
            setKnobPosition(currentAngle);  // Follow finger
        }
        return;
    }

    // --- Mode: TERMINAL → allow reverse gesture to rewind ---
    if (mode === "TERMINAL") {
        if (isReverseGesture(delta, arc)) {
            knob.classList.remove('dragging');
            rewind();
            state.wheel.navConsumed = true;
            triggerHaptic(15);
        } else {
            setKnobPosition(currentAngle);  // Follow finger
        }
        return;
    }

    // --- Mode: DECISION → cycle options or rewind (knob locked at anchor) ---
    if (mode === "DECISION") {
        handleDecisionWheelDrag(card, delta, currentAngle, arc);
        return;
    }

    // --- Modes: LINEAR / LOOP → snap to next/previous anchor ---
    if (isForwardGesture(delta, arc)) {
        knob.classList.remove('dragging');  // Enable transition -> smooth snap
        advance({ source: 'wheel-drag' });
        state.wheel.navConsumed = true;
        triggerHaptic(15);
        return;
    }

    if (isReverseGesture(delta, arc)) {
        knob.classList.remove('dragging');
        rewind();
        state.wheel.navConsumed = true;
        triggerHaptic(15);
        return;
    }
    // Below threshold → knob follows finger for responsive feel
    setKnobPosition(currentAngle);
}

function endKnobDrag() {
    if (!isDraggingKnob) return;
    isDraggingKnob = false;

    knob.classList.remove('dragging');  // Enable transition → smooth snap back
    state.wheel.dragOrigin = null;
    state.wheel.navConsumed = false;

    // Smooth snap back to current anchor
    state.wheel.angle = currentAnchorAngle();
    setKnobPosition(state.wheel.angle);
}

// (Decision drag-to-confirm handling is in renderPreviewZone section)

// ========================================
// TIMER
// ========================================
function startTimer() {
    state.timerRunning = true;
    state.timerInterval = setInterval(() => {
        state.timerSeconds++;
        updateTimerDisplay();
    }, 1000);
}

function updateTimerDisplay() {
    const h = Math.floor(state.timerSeconds / 3600);
    const m = Math.floor((state.timerSeconds % 3600) / 60);
    const s = state.timerSeconds % 60;
    timerEl.textContent = [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
}

// ========================================
// TOOLBOX / MODAL
// ========================================
function openToolbox() {
    modalOverlay.classList.add('visible');
}

function closeModal() {
    modalOverlay.classList.remove('visible');
}

function openFullscreen() {
    // Placeholder for fullscreen functionality
    alert('Fullscreen mode - would expand card details');
}

// ========================================
// CAROUSEL (for cards with multiple slides)
// ========================================
activeCard.addEventListener('click', (e) => {
    const card = DECK[state.currentId];
    if (card.type === 'carousel_action' && card.content.slides?.length > 1) {
        // Simple: click cycles through slides
        const rect = activeCard.getBoundingClientRect();
        const x = e.clientX - rect.left;
        
        if (x > rect.width / 2) {
            // Click right half: next slide
            state.carouselIndex = (state.carouselIndex + 1) % card.content.slides.length;
        } else {
            // Click left half: prev slide
            state.carouselIndex = (state.carouselIndex - 1 + card.content.slides.length) % card.content.slides.length;
        }
        render();
    }
});

function summarizeTransition(card) {
    const transitions = card && card.transitions ? card.transitions : null;
    if (!transitions) return null;

    const options = Array.isArray(transitions.options)
        ? transitions.options.map((opt, idx) => ({
            index: idx,
            label: opt.label || `option-${idx + 1}`,
            sub_label: opt.sub_label || null,
            target_id: opt.target_id || null,
            preview_card_title: opt.preview_card_title || null,
          }))
        : [];

    return {
        type: transitions.type || null,
        next_id: transitions.next_id || null,
        options,
    };
}

function normalizeDecisionIndexForCard(card, requestedIndex) {
    if (!card || !card.transitions || card.transitions.type !== 'split') return 0;
    const options = Array.isArray(card.transitions.options) ? card.transitions.options : [];
    if (options.length === 0) return 0;
    const value = Number.isFinite(requestedIndex) ? Math.floor(requestedIndex) : 0;
    return Math.max(0, Math.min(options.length - 1, value));
}

function resetTimerState() {
    if (state.timerInterval) {
        clearInterval(state.timerInterval);
    }
    state.timerInterval = null;
    state.timerRunning = false;
    state.timerSeconds = 0;
    updateTimerDisplay();
}

function snapshotForAutomation() {
    const card = DECK[state.currentId] || null;
    return {
        currentId: state.currentId,
        algorithmSource: ACTIVE_ALGORITHM_SOURCE,
        history: [...state.history],
        historySize: state.history.length,
        decisionIndex: state.decisionIndex,
        decisionRecords: { ...state.decisionRecords },
        decisionTrail: state.decisionTrail.slice(-30),
        carouselIndex: state.carouselIndex,
        timerSeconds: state.timerSeconds,
        anchors: state.anchors.map(function (a) { return { id: a.id, angle: a.angle }; }),
        anchorIndex: state.anchorIndex,
        decisionTapped: state.decisionTapped,
        wheel: {
            mode: state.wheel.mode,
            angle: state.wheel.angle,
        },
        card: card ? {
            id: card.id,
            type: card.type,
            status: card.status || null,
            title: (card.content && card.content.title) ? card.content.title : '',
            phase: (card.wheel_config && card.wheel_config.phase) ? card.wheel_config.phase : null,
            canonicalAngle: canonicalAngleForCard(card, state.wheel.angle),
            transitions: summarizeTransition(card),
        } : null,
    };
}

function setCurrentCardForAutomation(cardId) {
    const card = DECK[cardId];
    if (!card) {
        return {
            ok: false,
            error: `Unknown card id: ${cardId}`,
            snapshot: snapshotForAutomation(),
        };
    }

    state.currentId = card.id;
    state.history = [];
    if (isSplitDecisionCard(card)) {
        state.decisionIndex = rememberedDecisionIndexForCard(card);
    } else {
        state.decisionIndex = 0;
    }
    state.decisionTapped = false;
    state.carouselIndex = 0;
    state.wheel.mode = computeWheelMode(card);
    state.wheel.dragOrigin = null;
    state.wheel.navConsumed = false;
    resetTimerState();
    render();
    // render() calls syncAnchors() which sets wheel.angle to anchor position

    return {
        ok: true,
        error: null,
        snapshot: snapshotForAutomation(),
    };
}

window.__WARDEN_AUTOMATION = {
    version: '1.0',
    listCards() {
        return RUNTIME_ALGORITHM.deck.map((card) => card.id);
    },
    listAvailableAlgorithms() {
        return discoverAvailableAlgorithmFiles();
    },
    async loadAlgorithm(fileName) {
        try {
            const loaded = await loadAlgorithmByFileName(fileName);
            const result = applyAlgorithm(loaded, fileName);
            return {
                ok: true,
                error: null,
                ...result,
                snapshot: snapshotForAutomation(),
            };
        } catch (err) {
            return {
                ok: false,
                error: err && err.message ? err.message : String(err),
                snapshot: snapshotForAutomation(),
            };
        }
    },
    getModel() {
        return {
            start_id: currentAlgorithmStartId(),
            algorithm_source: ACTIVE_ALGORITHM_SOURCE,
            algorithm_meta: RUNTIME_ALGORITHM.algorithm_meta || null,
            cards: RUNTIME_ALGORITHM.deck.map((card) => ({
                id: card.id,
                type: card.type,
                status: card.status || null,
                title: (card.content && card.content.title) ? card.content.title : '',
                wheel: card.wheel_config || null,
                transitions: summarizeTransition(card),
            })),
        };
    },
    getSnapshot() {
        return snapshotForAutomation();
    },
    reset() {
        const startId = currentAlgorithmStartId() || state.currentId;
        return setCurrentCardForAutomation(startId);
    },
    gotoCard(cardId) {
        return setCurrentCardForAutomation(cardId);
    },
    selectDecisionOption(index) {
        const card = DECK[state.currentId];
        if (!card || !card.transitions || card.transitions.type !== 'split') {
            return {
                ok: false,
                error: 'Current card is not a split decision card',
                snapshot: snapshotForAutomation(),
            };
        }
        state.decisionIndex = normalizeDecisionIndexForCard(card, index);
        state.decisionTapped = true;
        render();
        return {
            ok: true,
            error: null,
            snapshot: snapshotForAutomation(),
        };
    },
    advance() {
        const beforeId = state.currentId;
        const moved = advance({ source: 'automation', splitConfirmed: true });
        return {
            ok: true,
            error: null,
            moved,
            before_id: beforeId,
            after_id: state.currentId,
            snapshot: snapshotForAutomation(),
        };
    },
    back() {
        const beforeId = state.currentId;
        rewind();
        return {
            ok: true,
            error: null,
            before_id: beforeId,
            after_id: state.currentId,
            snapshot: snapshotForAutomation(),
        };
    },
};

// ========================================
// INIT
// ========================================

function canTapAdvance(card) {
    if (!card || card.status === 'complete') return false;
    if (isSplitDecisionCard(card)) return false;
    return true;
}

// Click on wheel = advance (backup interaction)
wheel.addEventListener('click', (e) => {
    if (e.target === knob) return;
    const card = DECK[state.currentId];
    if (!canTapAdvance(card)) return;
    advance({ source: 'wheel-tap' });
});

// Click on knob = advance (backup interaction)
knob.addEventListener('click', (e) => {
    const card = DECK[state.currentId];
    if (!canTapAdvance(card)) return;
    advance({ source: 'knob-tap' });
});

// Keyboard Navigation
knob.addEventListener('keydown', (e) => {
    const card = DECK[state.currentId];
    if (!card) return;

    // Arrow Left: Rewind
    if (e.key === 'ArrowLeft') {
        rewind();
        e.preventDefault();
        return;
    }

    // Arrow Right: Advance
    if (e.key === 'ArrowRight') {
        if (state.wheel.mode === 'DECISION') {
            if (!state.decisionTapped) {
                // Select first option if none selected
                selectDecisionOption(state.decisionIndex || 0);
            } else {
                // Confirm and advance
                advance({ source: 'keyboard', splitConfirmed: true });
            }
        } else {
            advance({ source: 'keyboard' });
        }
        e.preventDefault();
        return;
    }

    // Up/Down: Cycle Options (Decision Mode only)
    if (state.wheel.mode === 'DECISION') {
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
             const options = card.transitions.options || [];
             if (options.length === 0) return;

             let newIndex = state.decisionIndex;
             if (e.key === 'ArrowDown') newIndex++;
             if (e.key === 'ArrowUp') newIndex--;

             // Wrap around
             if (newIndex >= options.length) newIndex = 0;
             if (newIndex < 0) newIndex = options.length - 1;

             selectDecisionOption(newIndex);
             e.preventDefault();
        }
    }
});

initAlgorithmFromUrl();
</script>
</body>
</html>
